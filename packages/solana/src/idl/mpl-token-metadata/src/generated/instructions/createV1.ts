/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import {
    Amount,
    Context,
    Option,
    OptionOrNullable,
    Pda,
    PublicKey,
    Signer,
    TransactionBuilder,
    mapAmountSerializer,
    none,
    publicKey,
    transactionBuilder,
} from '@metaplex-foundation/umi';
import {
    Serializer,
    array,
    bool,
    mapSerializer,
    option,
    publicKey as publicKeySerializer,
    string,
    struct,
    u16,
    u8,
} from '@metaplex-foundation/umi/serializers';
import {
    resolveCollectionDetails,
    resolveCreateV1Bytes,
    resolveCreators,
    resolveDecimals,
    resolveIsNonFungible,
    resolvePrintSupply,
} from '../../hooked';
import { findMasterEditionPda, findMetadataPda } from '../accounts';
import {
    PickPartial,
    ResolvedAccount,
    ResolvedAccountsWithIndices,
    expectPublicKey,
    expectSome,
    getAccountMetasAndSigners,
} from '../shared';
import {
    Collection,
    CollectionArgs,
    CollectionDetails,
    CollectionDetailsArgs,
    Creator,
    CreatorArgs,
    PrintSupply,
    PrintSupplyArgs,
    TokenStandard,
    TokenStandardArgs,
    Uses,
    UsesArgs,
    getCollectionDetailsSerializer,
    getCollectionSerializer,
    getCreatorSerializer,
    getPrintSupplySerializer,
    getTokenStandardSerializer,
    getUsesSerializer,
} from '../types';

// Accounts.
export type CreateV1InstructionAccounts = {
    /** Unallocated metadata account with address as pda of ['metadata', program id, mint id] */
    metadata?: PublicKey | Pda;
    /** Unallocated edition account with address as pda of ['metadata', program id, mint, 'edition'] */
    masterEdition?: PublicKey | Pda;
    /** Mint of token asset */
    mint: PublicKey | Pda | Signer;
    /** Mint authority */
    authority?: Signer;
    /** Payer */
    payer?: Signer;
    /** Update authority for the metadata account */
    updateAuthority?: PublicKey | Pda | Signer;
    /** System program */
    systemProgram?: PublicKey | Pda;
    /** Instructions sysvar account */
    sysvarInstructions?: PublicKey | Pda;
    /** SPL Token program */
    splTokenProgram?: PublicKey | Pda;
};

// Data.
export type CreateV1InstructionData = {
    discriminator: number;
    createV1Discriminator: number;
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: Amount<'%', 2>;
    creators: Option<Array<Creator>>;
    primarySaleHappened: boolean;
    isMutable: boolean;
    tokenStandard: TokenStandard;
    collection: Option<Collection>;
    uses: Option<Uses>;
    collectionDetails: Option<CollectionDetails>;
    ruleSet: Option<PublicKey>;
    decimals: Option<number>;
    printSupply: Option<PrintSupply>;
};

export type CreateV1InstructionDataArgs = {
    name: string;
    symbol?: string;
    uri: string;
    sellerFeeBasisPoints: Amount<'%', 2>;
    creators: OptionOrNullable<Array<CreatorArgs>>;
    primarySaleHappened?: boolean;
    isMutable?: boolean;
    tokenStandard: TokenStandardArgs;
    collection?: OptionOrNullable<CollectionArgs>;
    uses?: OptionOrNullable<UsesArgs>;
    collectionDetails?: OptionOrNullable<CollectionDetailsArgs>;
    ruleSet?: OptionOrNullable<PublicKey>;
    decimals?: OptionOrNullable<number>;
    printSupply?: OptionOrNullable<PrintSupplyArgs>;
};

export function getCreateV1InstructionDataSerializer(): Serializer<
    CreateV1InstructionDataArgs,
    CreateV1InstructionData
> {
    return mapSerializer<
        CreateV1InstructionDataArgs,
        any,
        CreateV1InstructionData
    >(
        struct<CreateV1InstructionData>(
            [
                ['discriminator', u8()],
                ['createV1Discriminator', u8()],
                ['name', string()],
                ['symbol', string()],
                ['uri', string()],
                ['sellerFeeBasisPoints', mapAmountSerializer(u16(), '%', 2)],
                ['creators', option(array(getCreatorSerializer()))],
                ['primarySaleHappened', bool()],
                ['isMutable', bool()],
                ['tokenStandard', getTokenStandardSerializer()],
                ['collection', option(getCollectionSerializer())],
                ['uses', option(getUsesSerializer())],
                ['collectionDetails', option(getCollectionDetailsSerializer())],
                ['ruleSet', option(publicKeySerializer())],
                ['decimals', option(u8())],
                ['printSupply', option(getPrintSupplySerializer())],
            ],
            { description: 'CreateV1InstructionData' }
        ),
        (value) => ({
            ...value,
            discriminator: 42,
            createV1Discriminator: 0,
            symbol: value.symbol ?? '',
            primarySaleHappened: value.primarySaleHappened ?? false,
            isMutable: value.isMutable ?? true,
            collection: value.collection ?? none(),
            uses: value.uses ?? none(),
            collectionDetails: value.collectionDetails ?? none(),
            ruleSet: value.ruleSet ?? none(),
            decimals: value.decimals ?? none(),
            printSupply: value.printSupply ?? none(),
        })
    ) as Serializer<CreateV1InstructionDataArgs, CreateV1InstructionData>;
}

// Extra Args.
export type CreateV1InstructionExtraArgs = { isCollection: boolean };

// Args.
export type CreateV1InstructionArgs = PickPartial<
    CreateV1InstructionDataArgs & CreateV1InstructionExtraArgs,
    | 'tokenStandard'
    | 'isCollection'
    | 'collectionDetails'
    | 'decimals'
    | 'printSupply'
    | 'creators'
>;

// Instruction.
export function createV1(
    context: Pick<Context, 'eddsa' | 'identity' | 'payer' | 'programs'>,
    input: CreateV1InstructionAccounts & CreateV1InstructionArgs
): TransactionBuilder {
    // Program ID.
    const programId = context.programs.getPublicKey(
        'mplTokenMetadata',
        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'
    );

    // Accounts.
    const resolvedAccounts: ResolvedAccountsWithIndices = {
        metadata: { index: 0, isWritable: true, value: input.metadata ?? null },
        masterEdition: {
            index: 1,
            isWritable: true,
            value: input.masterEdition ?? null,
        },
        mint: { index: 2, isWritable: true, value: input.mint ?? null },
        authority: {
            index: 3,
            isWritable: false,
            value: input.authority ?? null,
        },
        payer: { index: 4, isWritable: true, value: input.payer ?? null },
        updateAuthority: {
            index: 5,
            isWritable: false,
            value: input.updateAuthority ?? null,
        },
        systemProgram: {
            index: 6,
            isWritable: false,
            value: input.systemProgram ?? null,
        },
        sysvarInstructions: {
            index: 7,
            isWritable: false,
            value: input.sysvarInstructions ?? null,
        },
        splTokenProgram: {
            index: 8,
            isWritable: false,
            value: input.splTokenProgram ?? null,
        },
    };

    // Arguments.
    const resolvedArgs: CreateV1InstructionArgs = { ...input };

    // Default values.
    if (!resolvedAccounts.metadata.value) {
        resolvedAccounts.metadata.value = findMetadataPda(context, {
            mint: expectPublicKey(resolvedAccounts.mint.value),
        });
    }
    if (!resolvedArgs.tokenStandard) {
        resolvedArgs.tokenStandard = TokenStandard.NonFungible;
    }
    if (!resolvedAccounts.masterEdition.value) {
        if (
            resolveIsNonFungible(
                context,
                resolvedAccounts,
                resolvedArgs,
                programId,
                true
            )
        ) {
            resolvedAccounts.masterEdition.value = findMasterEditionPda(
                context,
                {
                    mint: expectPublicKey(resolvedAccounts.mint.value),
                }
            );
        }
    }
    if (!resolvedAccounts.authority.value) {
        resolvedAccounts.authority.value = context.identity;
    }
    if (!resolvedAccounts.payer.value) {
        resolvedAccounts.payer.value = context.payer;
    }
    if (!resolvedAccounts.updateAuthority.value) {
        resolvedAccounts.updateAuthority.value = expectSome(
            resolvedAccounts.authority.value
        );
    }
    if (!resolvedAccounts.systemProgram.value) {
        resolvedAccounts.systemProgram.value = context.programs.getPublicKey(
            'splSystem',
            '11111111111111111111111111111111'
        );
        resolvedAccounts.systemProgram.isWritable = false;
    }
    if (!resolvedAccounts.sysvarInstructions.value) {
        resolvedAccounts.sysvarInstructions.value = publicKey(
            'Sysvar1nstructions1111111111111111111111111'
        );
    }
    if (!resolvedAccounts.splTokenProgram.value) {
        resolvedAccounts.splTokenProgram.value = context.programs.getPublicKey(
            'splToken',
            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'
        );
        resolvedAccounts.splTokenProgram.isWritable = false;
    }
    if (!resolvedArgs.isCollection) {
        resolvedArgs.isCollection = false;
    }
    if (!resolvedArgs.collectionDetails) {
        resolvedArgs.collectionDetails = resolveCollectionDetails(
            context,
            resolvedAccounts,
            resolvedArgs,
            programId,
            false
        );
    }
    if (!resolvedArgs.decimals) {
        resolvedArgs.decimals = resolveDecimals(
            context,
            resolvedAccounts,
            resolvedArgs,
            programId,
            false
        );
    }
    if (!resolvedArgs.printSupply) {
        resolvedArgs.printSupply = resolvePrintSupply(
            context,
            resolvedAccounts,
            resolvedArgs,
            programId,
            false
        );
    }
    if (!resolvedArgs.creators) {
        resolvedArgs.creators = resolveCreators(
            context,
            resolvedAccounts,
            resolvedArgs,
            programId,
            false
        );
    }

    // Accounts in order.
    const orderedAccounts: ResolvedAccount[] = Object.values(
        resolvedAccounts
    ).sort((a, b) => a.index - b.index);

    // Keys and Signers.
    const [keys, signers] = getAccountMetasAndSigners(
        orderedAccounts,
        'programId',
        programId
    );

    // Data.
    const data = getCreateV1InstructionDataSerializer().serialize(
        resolvedArgs as CreateV1InstructionDataArgs
    );

    // Bytes Created On Chain.
    const bytesCreatedOnChain = resolveCreateV1Bytes(
        context,
        resolvedAccounts,
        resolvedArgs,
        programId
    );

    return transactionBuilder([
        {
            instruction: { keys, programId, data },
            signers,
            bytesCreatedOnChain,
        },
    ]);
}
